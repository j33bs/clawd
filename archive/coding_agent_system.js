// coding_agent_system.js
// Main orchestrator for the multi-agent coding system
// Implements the architecture described in CODING_AGENT_ARCHITECTURE.md
// Ready to integrate Codex after February 5th

const { MultiAgentFramework } = require('./multi_agent_framework');
const TaskScheduler = require('./task_scheduler');

class CodingAgentSystem {
  constructor(config = {}) {
    this.framework = new MultiAgentFramework(config.framework || {});
    this.scheduler = new TaskScheduler(this.framework);
    this.config = {
      enableCodexIntegration: false, // Will be enabled after Feb 5th
      codexApiKey: config.codexApiKey || null,
      codexEndpoint: config.codexEndpoint || 'https://api.openai.com/v1/',
      ...config
    };
    
    this.systemInitialized = false;
    this.schedulerStarted = false;
    this.monitoringStarted = false;
    
    // Store for post-February 5th initialization
    this.postFeb5Initialized = false;
  }

  // Initialize the system
  // Note: Scheduler and monitoring loops are NOT auto-started.
  // Call startScheduler() and startMonitoring() explicitly if needed.
  async initialize() {
    console.log('Initializing Coding Agent System...');

    this.systemInitialized = true;
    console.log('Coding Agent System initialized successfully');

    // Check if we should enable Codex integration (after Feb 5th)
    if (this.isAfterFeb5th()) {
      await this.enableCodexIntegration();
    }

    return true;
  }

  // Explicitly start the scheduler and monitoring loops
  startLoops(schedulerInterval = 10000, monitorInterval = 30000) {
    if (!this.schedulerStarted) {
      this.scheduler.startScheduler(schedulerInterval);
      this.schedulerStarted = true;
      console.log(`Scheduler started (interval: ${schedulerInterval}ms)`);
    }
    if (!this.monitoringStarted) {
      this.scheduler.startMonitoring(monitorInterval);
      this.monitoringStarted = true;
      console.log(`Monitoring started (interval: ${monitorInterval}ms)`);
    }
  }

  // Enable Codex integration (called after Feb 5th)
  async enableCodexIntegration() {
    if (this.postFeb5Initialized) {
      return; // Already initialized
    }
    
    console.log('Enabling Codex integration...');
    
    // Validate Codex configuration
    if (!this.config.codexApiKey) {
      console.warn('Codex API key not configured. Please set codexApiKey in config.');
      return false;
    }
    
    // Update configuration to enable Codex
    this.config.enableCodexIntegration = true;
    
    // Initialize Codex client
    try {
      // This would be implemented with actual Codex integration
      this.codexClient = this.initializeCodexClient();
      console.log('Codex integration enabled successfully');
      
      // Update framework to use Codex for heavy tasks
      this.framework.enableCodexIntegration = true;
      
      this.postFeb5Initialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize Codex integration:', error);
      return false;
    }
  }

  // Initialize Codex client (placeholder for actual implementation)
  initializeCodexClient() {
    // In the actual implementation, this would create a client to communicate with Codex
    return {
      async generateCode(prompt, options = {}) {
        // Placeholder for actual Codex API call
        console.log(`[CODEX CALL] Generating code for: ${prompt.substring(0, 50)}...`);
        return `/* Generated by Codex: ${prompt.substring(0, 100)} */\n// This would be actual Codex-generated code`;
      },
      
      async refactorCode(code, requirements) {
        // Placeholder for actual Codex refactoring
        console.log(`[CODEX CALL] Refactoring code: ${code.substring(0, 50)}...`);
        return `/* Refactored by Codex */\n${code}// Refactored to meet requirements: ${requirements}`;
      },
      
      async explainCode(code) {
        // Placeholder for actual Codex explanation
        console.log(`[CODEX CALL] Explaining code: ${code.substring(0, 50)}...`);
        return `/* Explanation by Codex */\n// This code does the following: ...`;
      }
    };
  }

  // Submit a task to the system
  async submitTask(task, options = {}) {
    if (!this.systemInitialized) {
      await this.initialize();
    }
    
    // Schedule the task
    const taskId = await this.scheduler.scheduleTask(task, options);
    
    console.log(`Task submitted with ID: ${taskId}`);
    return taskId;
  }

  // Process a task directly (bypassing scheduler)
  async processTask(task, options = {}) {
    if (!this.systemInitialized) {
      await this.initialize();
    }
    
    // Classify the task using the framework
    const classification = this.framework.classifyTask(task);
    
    // If Codex integration is enabled and task requires Codex, divert to Codex
    if (this.config.enableCodexIntegration && classification.requiresCodex) {
      return this.processViaCodex(task, classification, options);
    }
    
    // Otherwise, process through the framework
    return this.framework.processTask(task, options);
  }

  // Process task via Codex (after Feb 5th)
  async processViaCodex(task, classification, options = {}) {
    if (!this.codexClient) {
      throw new Error('Codex client not initialized. Check Codex configuration.');
    }
    
    try {
      // Determine the appropriate Codex function based on task type
      let result;
      
      if (classification.type === 'coding') {
        if (classification.complexity === 'high') {
          // Use code generation for complex tasks
          result = await this.codexClient.generateCode(task, options);
        } else {
          // Use explanation for simpler tasks
          result = await this.codexClient.explainCode(task);
        }
      } else {
        // For non-coding tasks, use general generation
        result = await this.codexClient.generateCode(`Task: ${task}`, options);
      }
      
      return {
        success: true,
        result,
        agentId: 'codex_client',
        classification,
        tokensUsed: Math.ceil(task.length / 4), // Rough token estimation
        processedViaCodex: true
      };
    } catch (error) {
      console.error('Codex processing failed:', error);
      
      // Fallback to regular framework processing
      console.log('Falling back to regular agent processing...');
      return this.framework.processTask(task, options);
    }
  }

  // Check if current date is after Feb 5th
  isAfterFeb5th() {
    const now = new Date();
    const feb5th = new Date(now.getFullYear(), 1, 5); // Month is 0-indexed (Jan=0, Feb=1)
    return now >= feb5th;
  }

  // Get system status
  getStatus() {
    return {
      initialized: this.systemInitialized,
      codexEnabled: this.config.enableCodexIntegration,
      postFeb5Ready: this.postFeb5Initialized,
      frameworkStats: this.framework.getStats(),
      schedulerStats: this.scheduler.getStats(),
      agentInfo: this.framework.getAgentInfo(),
      currentDateTime: new Date().toISOString(),
      isAfterFeb5th: this.isAfterFeb5th()
    };
  }

  // Get task status
  getTaskStatus(taskId) {
    return this.scheduler.getTaskStatus(taskId);
  }

  // Cancel a task
  cancelTask(taskId) {
    return this.scheduler.cancelTask(taskId);
  }

  // Shutdown the system gracefully
  async shutdown() {
    console.log('Shutting down Coding Agent System...');
    
    // Stop scheduler
    if (this.schedulerStarted) {
      this.scheduler.stopScheduler();
      this.schedulerStarted = false;
    }
    
    // Stop monitoring
    if (this.monitoringStarted) {
      this.scheduler.stopMonitoring();
      this.monitoringStarted = false;
    }
    
    // Perform any cleanup
    this.systemInitialized = false;
    this.postFeb5Initialized = false;
    
    console.log('Coding Agent System shutdown complete');
    return true;
  }

  // Monitor system and automatically enable Codex after Feb 5th
  async startAutoEnableMonitor() {
    // Check immediately
    if (this.isAfterFeb5th() && !this.postFeb5Initialized) {
      await this.enableCodexIntegration();
    }
    
    // Set up periodic check (every hour)
    const interval = setInterval(async () => {
      if (this.isAfterFeb5th() && !this.postFeb5Initialized) {
        console.log('Current date is after February 5th, enabling Codex integration...');
        await this.enableCodexIntegration();
        clearInterval(interval); // Stop checking once enabled
      }
    }, 3600000); // Check every hour
    
    return interval;
  }

  // Manual trigger for Codex integration (for testing before Feb 5th)
  async forceEnableCodex(apiKey) {
    if (apiKey) {
      this.config.codexApiKey = apiKey;
    }
    
    return await this.enableCodexIntegration();
  }
}

// Export the system
module.exports = CodingAgentSystem;

// If running directly, start the system (no background loops by default)
if (require.main === module) {
  console.log('Starting Coding Agent System...');

  const system = new CodingAgentSystem({
    framework: {
      primaryTokenLimit: 4000,
      secondaryTokenLimit: 2000,
      maxConcurrentAgents: 5
    }
  });

  system.initialize()
    .then(() => {
      console.log('System ready. Call system.startLoops() to enable scheduler/monitoring.');
    })
    .catch(console.error);
}