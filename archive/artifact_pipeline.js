// artifact_pipeline.js
// Generate DOCX and spreadsheet report templates with validation checks

const fs = require('fs');
const path = require('path');

class ArtifactPipeline {
  constructor(config = {}) {
    this.config = {
      artifactsDir: config.artifactsDir || './artifacts',
      templatesDir: config.templatesDir || './templates',
      validationRules: {
        docx: {
          requiredFields: ['title', 'author', 'content'],
          contentMinLength: 10,
          contentMaxLength: 50000
        },
        spreadsheet: {
          requiredFields: ['data', 'columns'],
          maxRows: 10000,
          maxCols: 100
        }
      },
      ...config
    };
    
    // Initialize directories
    this.initDirectories();
  }

  // Initialize required directories
  initDirectories() {
    if (!fs.existsSync(this.config.artifactsDir)) {
      fs.mkdirSync(this.config.artifactsDir, { recursive: true });
    }
    
    if (!fs.existsSync(this.config.templatesDir)) {
      fs.mkdirSync(this.config.templatesDir, { recursive: true });
    }
  }

  // Generate DOCX report
  async generateDocxReport(templateData, filename = null) {
    // Validate input data
    const validation = this.validateDocxData(templateData);
    if (!validation.valid) {
      throw new Error(`DOCX validation failed: ${validation.error}`);
    }

    // Generate filename if not provided
    const outputFilename = filename || `report_${Date.now()}.docx`;
    const outputPath = path.join(this.config.artifactsDir, outputFilename);

    // In a real implementation, this would use a library like docx to generate actual DOCX
    // For now, we'll create a simple placeholder that represents the structure
    const reportContent = this.createDocxPlaceholder(templateData);

    // Write placeholder content (in real implementation, this would be actual DOCX binary)
    fs.writeFileSync(outputPath, reportContent);

    // Return artifact info
    return {
      type: 'docx',
      path: outputPath,
      filename: outputFilename,
      size: fs.statSync(outputPath).size,
      generatedAt: new Date().toISOString(),
      templateUsed: templateData.template || 'default',
      validation: validation
    };
  }

  // Validate DOCX data
  validateDocxData(data) {
    const rules = this.config.validationRules.docx;

    // Check required fields
    for (const field of rules.requiredFields) {
      if (!(field in data)) {
        return { valid: false, error: `Missing required field: ${field}` };
      }
    }

    // Validate content length
    if (typeof data.content === 'string') {
      if (data.content.length < rules.contentMinLength) {
        return { valid: false, error: `Content too short (minimum ${rules.contentMinLength} characters)` };
      }
      if (data.content.length > rules.contentMaxLength) {
        return { valid: false, error: `Content too long (maximum ${rules.contentMaxLength} characters)` };
      }
    }

    // Validate title length
    if (typeof data.title === 'string' && data.title.length > 200) {
      return { valid: false, error: 'Title too long (maximum 200 characters)' };
    }

    // Validate author
    if (typeof data.author === 'string' && data.author.length > 100) {
      return { valid: false, error: 'Author name too long (maximum 100 characters)' };
    }

    return { valid: true, error: null };
  }

  // Create DOCX placeholder content
  createDocxPlaceholder(data) {
    const timestamp = new Date().toISOString();
    
    let content = `DOCX REPORT TEMPLATE\n`;
    content += `==================\n\n`;
    content += `Title: ${data.title || 'Untitled'}\n`;
    content += `Author: ${data.author || 'Unknown'}\n`;
    content += `Generated: ${timestamp}\n`;
    content += `Template: ${data.template || 'default'}\n\n`;
    
    content += `CONTENT\n`;
    content += `=======\n`;
    content += `${data.content || 'No content provided'}\n\n`;
    
    if (data.metadata) {
      content += `METADATA\n`;
      content += `========\n`;
      for (const [key, value] of Object.entries(data.metadata)) {
        content += `${key}: ${value}\n`;
      }
      content += `\n`;
    }
    
    if (data.sections) {
      content += `SECTIONS\n`;
      content += `========\n`;
      data.sections.forEach((section, index) => {
        content += `\n${index + 1}. ${section.title || `Section ${index + 1}`}\n`;
        content += `${section.content || 'No content'}\n`;
      });
      content += `\n`;
    }
    
    content += `---\nReport generated by Artifact Pipeline\n`;
    
    return content;
  }

  // Generate spreadsheet report
  async generateSpreadsheetReport(templateData, filename = null, format = 'csv') {
    // Validate input data
    const validation = this.validateSpreadsheetData(templateData);
    if (!validation.valid) {
      throw new Error(`Spreadsheet validation failed: ${validation.error}`);
    }

    // Generate filename if not provided
    const fileExt = format === 'xlsx' ? '.xlsx' : '.csv';
    const outputFilename = filename || `spreadsheet_${Date.now()}${fileExt}`;
    const outputPath = path.join(this.config.artifactsDir, outputFilename);

    // Generate spreadsheet content based on format
    let spreadsheetContent;
    if (format === 'csv') {
      spreadsheetContent = this.createCsvContent(templateData);
    } else {
      // For XLSX, we'd use a library like exceljs in a real implementation
      // For now, create CSV content as placeholder
      spreadsheetContent = this.createCsvContent(templateData);
    }

    // Write content to file
    fs.writeFileSync(outputPath, spreadsheetContent);

    // Return artifact info
    return {
      type: 'spreadsheet',
      subtype: format,
      path: outputPath,
      filename: outputFilename,
      size: fs.statSync(outputPath).size,
      generatedAt: new Date().toISOString(),
      rows: Array.isArray(templateData.data) ? templateData.data.length : 0,
      columns: Array.isArray(templateData.columns) ? templateData.columns.length : 0,
      validation: validation
    };
  }

  // Validate spreadsheet data
  validateSpreadsheetData(data) {
    const rules = this.config.validationRules.spreadsheet;

    // Check required fields
    for (const field of rules.requiredFields) {
      if (!(field in data)) {
        return { valid: false, error: `Missing required field: ${field}` };
      }
    }

    // Validate data array
    if (!Array.isArray(data.data)) {
      return { valid: false, error: 'Data must be an array' };
    }

    // Validate columns array
    if (!Array.isArray(data.columns)) {
      return { valid: false, error: 'Columns must be an array' };
    }

    // Validate row count
    if (data.data.length > rules.maxRows) {
      return { valid: false, error: `Too many rows (maximum ${rules.maxRows})` };
    }

    // Validate column count
    if (data.columns.length > rules.maxCols) {
      return { valid: false, error: `Too many columns (maximum ${rules.maxCols})` };
    }

    return { valid: true, error: null };
  }

  // Create CSV content
  createCsvContent(data) {
    // Create header row
    let csvContent = data.columns.join(',') + '\n';

    // Add data rows
    for (const row of data.data) {
      const csvRow = data.columns.map(col => {
        let value = row[col] || '';
        // Escape commas and quotes in values
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          value = '"' + value.replace(/"/g, '""') + '"';
        }
        return value;
      }).join(',');
      
      csvContent += csvRow + '\n';
    }

    return csvContent;
  }

  // Create template from specification
  async createTemplate(spec, templateName) {
    const templatePath = path.join(this.config.templatesDir, `${templateName}.json`);
    
    // Validate template spec
    if (!spec || typeof spec !== 'object') {
      throw new Error('Template specification must be an object');
    }

    // Save template
    fs.writeFileSync(templatePath, JSON.stringify(spec, null, 2));
    
    return {
      name: templateName,
      path: templatePath,
      created: new Date().toISOString()
    };
  }

  // Load existing template
  async loadTemplate(templateName) {
    const templatePath = path.join(this.config.templatesDir, `${templateName}.json`);
    
    if (!fs.existsSync(templatePath)) {
      throw new Error(`Template ${templateName} not found`);
    }

    const templateSpec = JSON.parse(fs.readFileSync(templatePath, 'utf8'));
    return templateSpec;
  }

  // Get list of available templates
  async listTemplates() {
    if (!fs.existsSync(this.config.templatesDir)) {
      return [];
    }

    const files = fs.readdirSync(this.config.templatesDir);
    return files
      .filter(file => file.endsWith('.json'))
      .map(file => file.replace('.json', ''));
  }

  // Validate generated artifact
  async validateArtifact(artifactPath, expectedType) {
    if (!fs.existsSync(artifactPath)) {
      return { valid: false, error: 'Artifact file does not exist' };
    }

    const stats = fs.statSync(artifactPath);
    const size = stats.size;
    const isValidType = artifactPath.endsWith(expectedType === 'docx' ? '.docx' : 
                           expectedType === 'csv' ? '.csv' : 
                           expectedType === 'xlsx' ? '.xlsx' : '');

    return {
      valid: isValidType && size > 0,
      size: size,
      path: artifactPath,
      typeMatch: isValidType
    };
  }

  // Get artifact statistics
  async getArtifactStats() {
    if (!fs.existsSync(this.config.artifactsDir)) {
      return { total: 0, size: 0, types: {} };
    }

    const files = fs.readdirSync(this.config.artifactsDir);
    let totalSize = 0;
    const typeCounts = {};

    for (const file of files) {
      const filePath = path.join(this.config.artifactsDir, file);
      const stat = fs.statSync(filePath);
      totalSize += stat.size;

      // Determine file type
      const ext = path.extname(file).substring(1).toLowerCase();
      typeCounts[ext] = (typeCounts[ext] || 0) + 1;
    }

    return {
      total: files.length,
      size: totalSize,
      types: typeCounts
    };
  }
}

module.exports = ArtifactPipeline;