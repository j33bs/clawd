#!/usr/bin/env bash
set -euo pipefail

# Local macOS Calendar bridge (read/write) via AppleScript.
# Usage:
#   calendar_bridge.sh list 2026-02-04 2026-02-05 [calendarNameOptional]
#   calendar_bridge.sh create "Title" "2026-02-04 14:00" "2026-02-04 15:00" "CalendarName" "Location" "Notes"
#   calendar_bridge.sh delete "<eventId>"
#   calendar_bridge.sh move "<eventId>" "2026-02-04 16:00" "2026-02-04 17:00"

cmd="${1:-}"
shift || true

escape_json () {
  # minimal JSON string escaping
  python3 - <<'PY' "$1"
import json,sys
print(json.dumps(sys.argv[1]))
PY
}

case "$cmd" in
  list)
    start_date="${1:?start YYYY-MM-DD}"
    end_date="${2:?end YYYY-MM-DD}"
    cal_name="${3:-}"

    osascript -l AppleScript - "$start_date" "$end_date" "$cal_name" <<'APPLESCRIPT'
  set y to year of d as integer
  set m to month of d as integer
  set dd to day of d as integer
  set hh to hours of d as integer
  set mm to minutes of d as integer
  set ss to seconds of d as integer
  return (y as string) & "-" & text -2 thru -1 of ("0" & (m as string)) & "-" & text -2 thru -1 of ("0" & (dd as string)) & "T" & text -2 thru -1 of ("0" & (hh as string)) & ":" & text -2 thru -1 of ("0" & (mm as string)) & ":" & text -2 thru -1 of ("0" & (ss as string))
end toISODate

on jsonEscape(t)
  set AppleScript's text item delimiters to {"\\"}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\\"}
  set t to t as string
  set AppleScript's text item delimiters to {"\""}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\""}
  set t to t as string
  set AppleScript's text item delimiters to {linefeed}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\n"}
  set t to t as string
  set AppleScript's text item delimiters to {return}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\r"}
  set t to t as string
  set AppleScript's text item delimiters to {tab}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\t"}
  set t to t as string
  set AppleScript's text item delimiters to {""}
  return t
end jsonEscape

on parseDateTime(s)
  -- expects "YYYY-MM-DD" or "YYYY-MM-DD HH:MM"
  set d to date (s)
  return d
end parseDateTime

set startStr to item 1 of argv
set endStr to item 2 of argv
set calName to item 3 of argv

set startDate to date (startStr & " 00:00:00")
set endDate to date (endStr & " 00:00:00")

tell application "Calendar"
  set evs to {}
  if calName is not "" then
    set targetCals to {calendar calName}
  else
    set targetCals to calendars
  end if

  repeat with c in targetCals
    set evList to (every event of c whose start date â‰¥ startDate and start date < endDate)
    repeat with e in evList
      set eid to uid of e
      set t to summary of e
      if t is missing value then set t to ""
      set loc to location of e
      if loc is missing value then set loc to ""
      set notes to description of e
      if notes is missing value then set notes to ""
      set sdt to start date of e
      set edt to end date of e
      set caln to name of c

      set end of evs to "{\"id\":\"" & jsonEscape(eid) & "\",\"title\":\"" & jsonEscape(t) & "\",\"calendar\":\"" & jsonEscape(caln) & "\",\"start\":\"" & toISODate(sdt) & "\",\"end\":\"" & toISODate(edt) & "\",\"location\":\"" & jsonEscape(loc) & "\",\"notes\":\"" & jsonEscape(notes) & "\"}"
    end repeat
  end repeat

  set out to "{\"ok\":true,\"events\":["
  set first to true
  repeat with j in evs
    if first then
      set out to out & j
      set first to false
    else
      set out to out & "," & j
    end if
  end repeat
  set out to out & "]}"
  return out
end tell
APPLESCRIPT
    ;;

  create)
    title="${1:?title}"
    start_dt="${2:?start 'YYYY-MM-DD HH:MM'}"
    end_dt="${3:?end 'YYYY-MM-DD HH:MM'}"
    cal_name="${4:?calendar name}"
    location="${5:-}"
    notes="${6:-}"

    osascript -l AppleScript <<'APPLESCRIPT' "$title" "$start_dt" "$end_dt" "$cal_name" "$location" "$notes"
on jsonEscape(t)
  set AppleScript's text item delimiters to {"\\"}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\\"}
  set t to t as string
  set AppleScript's text item delimiters to {"\""}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\""}
  set t to t as string
  set AppleScript's text item delimiters to {linefeed}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\n"}
  set t to t as string
  set AppleScript's text item delimiters to {""}
  return t
end jsonEscape

set title to item 1 of argv
set startStr to item 2 of argv
set endStr to item 3 of argv
set calName to item 4 of argv
set loc to item 5 of argv
set notes to item 6 of argv

set sdt to date startStr
set edt to date endStr

tell application "Calendar"
  set c to calendar calName
  set e to make new event at end of events of c with properties {summary:title, start date:sdt, end date:edt, location:loc, description:notes}
  set eid to uid of e
  return "{\"ok\":true,\"id\":\"" & jsonEscape(eid) & "\"}"
end tell
APPLESCRIPT
    ;;

  delete)
    eid="${1:?event id}"
    osascript -l AppleScript - ... <<'APPLESCRIPT'
on jsonEscape(t)
  set AppleScript's text item delimiters to {"\\"}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\\"}
  set t to t as string
  set AppleScript's text item delimiters to {"\""}
  set t to text items of t
  set AppleScript's text item delimiters to {"\\\""}
  set t to t as string
  set AppleScript's text item delimiters to {""}
  return t
end jsonEscape

set eid to item 1 of argv

tell application "Calendar"
  set deleted to false
  repeat with c in calendars
    set matches to (every event of c whose uid is eid)
    if (count of matches) > 0 then
      repeat with e in matches
        delete e
        set deleted to true
      end repeat
    end if
  end repeat
  if deleted then
    return "{\"ok\":true}"
  else
    return "{\"ok\":false,\"error\":\"not_found\"}"
  end if
end tell
APPLESCRIPT
    ;;

  move)
    eid="${1:?event id}"
    start_dt="${2:?start 'YYYY-MM-DD HH:MM'}"
    end_dt="${3:?end 'YYYY-MM-DD HH:MM'}"
set startStr to item 2 of argv
set endStr to item 3 of argv
set sdt to date startStr
set edt to date endStr

tell application "Calendar"
  set updated to false
  repeat with c in calendars
    set matches to (every event of c whose uid is eid)
    if (count of matches) > 0 then
      repeat with e in matches
        set start date of e to sdt
        set end date of e to edt
        set updated to true
      end repeat
    end if
  end repeat
  if updated then
    return "{\"ok\":true}"
  else
    return "{\"ok\":false,\"error\":\"not_found\"}"
  end if
end tell
APPLESCRIPT
    ;;

  *)
    echo "Usage:"
    echo "  $0 list YYYY-MM-DD YYYY-MM-DD [calendarName]"
    echo "  $0 create \"Title\" \"YYYY-MM-DD HH:MM\" \"YYYY-MM-DD HH:MM\" \"CalendarName\" \"Location\" \"Notes\""
    echo "  $0 delete \"<eventId>\""
    echo "  $0 move \"<eventId>\" \"YYYY-MM-DD HH:MM\" \"YYYY-MM-DD HH:MM\""
    exit 2
    ;;
esac
