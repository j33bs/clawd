#!/bin/bash
# OpenClaw Pre-Commit Hook (Tracked Template)
# Category: B (Security)
# Install: bash workspace/scripts/install-hooks.sh
#
# POLICY: This hook scans for live secrets. Placeholders are allowed.
#         Live secrets (real tokens, real API keys) must NEVER be committed.
#         See workspace/MEMORY.md "Secret Overlay Pattern" for rationale.

set -e

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

# Guardrail: hooks must be read-only (no worktree mutation).
HOOK_STATUS_BEFORE=$(git status --porcelain --untracked-files=normal 2>/dev/null || true)
enforce_read_only_hook() {
    HOOK_EXIT=$?
    HOOK_STATUS_AFTER=$(git status --porcelain --untracked-files=normal 2>/dev/null || true)
    if [ "$HOOK_STATUS_AFTER" != "$HOOK_STATUS_BEFORE" ]; then
        echo -e "${RED}ERROR: Hook mutated the worktree. Hooks must be read-only.${NC}"
        echo "Run explicit fix commands manually, then retry."
        echo "Changed paths:"
        git status --short
        exit 1
    fi
    exit $HOOK_EXIT
}
trap enforce_read_only_hook EXIT

echo "=== OpenClaw Pre-Commit Validation ==="

BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# ============================================
# 0. BLOCK: OPEN_QUESTIONS append-only policy
# ============================================
if ! bash "workspace/scripts/hooks/guard_open_questions_append_only.sh"; then
    exit 1
fi

# ============================================
# 1. BLOCK: Direct commits to main
# ============================================
if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
    echo -e "${RED}ERROR: Direct commits to main/master are blocked.${NC}"
    echo ""
    echo "Remediation:"
    echo "  1. Create a topic branch: git checkout -b feature/your-change"
    echo "  2. Make your changes there"
    echo "  3. Submit via PR to develop, then to main"
    echo ""
    echo "For emergencies, use: git checkout -b hotfix/description"
    exit 1
fi

# ============================================
# 2. BLOCK: Forbidden files
# ============================================
FORBIDDEN_FILES=(
    "secrets.env"
    ".env"
    "device.json"
    "paired.json"
    "pending.json"
    "device-auth.json"
    "auth-profiles.json"
)

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || echo "")

for forbidden in "${FORBIDDEN_FILES[@]}"; do
    if echo "$STAGED_FILES" | grep -qE "(^|/)${forbidden}$"; then
        echo -e "${RED}ERROR: Attempting to commit forbidden file: $forbidden${NC}"
        echo ""
        echo "This file contains secrets and MUST NOT be committed."
        echo "Remediation: git reset HEAD $forbidden"
        exit 1
    fi
done

# ============================================
# 3. BLOCK: Secret patterns in content
# ============================================
echo "[1/5] Scanning for secrets in staged content..."

SECRET_PATTERNS=(
    # Keep these patterns effective at runtime, but avoid self-matching the
    # installer/templates when scanned by hooks that look for these literals.
    "PRI""VATE KEY"
    "BE""GIN.*KE""Y"
    "bearer [a-zA-Z0-9_-]{20,}"
    "api[_-]?key.*[a-zA-Z0-9_-]{20,}"
    "token.*[a-zA-Z0-9_-]{32,}"
)

# Known placeholder values that are NOT live secrets.
# These exact strings are allowed in tracked files.
# POLICY: Only add placeholders here. NEVER add real credentials.
KNOWN_PLACEHOLDERS=(
    "oauth-via-claude-code"
    "qwen-oauth"
    "ollama"
    "PLACEHOLDER_SEE_SECRETS_ENV"
)

HAS_SECRETS=0
for file in $STAGED_FILES; do
    # Skip files that contain pattern definitions (not actual secrets)
    if [[ "$file" == *.md ]] || [[ "$file" == *.template ]] || [[ "$file" == *.gitignore ]] || [[ "$file" == *.sh ]]; then
        continue
    fi

    CONTENT=$(git show ":$file" 2>/dev/null || echo "")

    for pattern in "${SECRET_PATTERNS[@]}"; do
        MATCHES=$(echo "$CONTENT" | grep -iE "$pattern" 2>/dev/null || true)
        if [ -n "$MATCHES" ]; then
            # Check if every match line contains only known placeholders
            IS_PLACEHOLDER=1
            while IFS= read -r match_line; do
                LINE_HAS_PLACEHOLDER=0
                for placeholder in "${KNOWN_PLACEHOLDERS[@]}"; do
                    if echo "$match_line" | grep -qF "$placeholder"; then
                        LINE_HAS_PLACEHOLDER=1
                        break
                    fi
                done
                if [ "$LINE_HAS_PLACEHOLDER" -eq 0 ]; then
                    IS_PLACEHOLDER=0
                    break
                fi
            done <<< "$MATCHES"

            if [ "$IS_PLACEHOLDER" -eq 0 ]; then
                echo -e "${RED}WARNING: Potential secret pattern found in $file${NC}"
                echo "  Pattern: $pattern"
                HAS_SECRETS=1
            fi
        fi
    done
done

if [ $HAS_SECRETS -eq 1 ]; then
    echo ""
    echo -e "${RED}ERROR: Potential secrets detected in staged files.${NC}"
    echo ""
    echo "Remediation:"
    echo "  1. Review the flagged files"
    echo "  2. Replace live secrets with placeholders"
    echo "  3. Store real values in secrets.env (gitignored)"
    echo ""
    echo "Known placeholders (allowed): ${KNOWN_PLACEHOLDERS[*]}"
    exit 1
fi

echo -e "${GREEN}  No secrets detected${NC}"

# ============================================
# 4. WARN: Non-conforming branch names
# ============================================
echo "[2/5] Checking branch naming convention..."

VALID_PREFIXES="feature/|security/|docs/|governance/|hotfix/|develop"

if [ -n "$BRANCH" ] && [ "$BRANCH" != "HEAD" ]; then
    if ! echo "$BRANCH" | grep -qE "^($VALID_PREFIXES)"; then
        echo -e "${YELLOW}WARNING: Branch name '$BRANCH' does not follow convention.${NC}"
        echo "  Expected prefixes: feature/, security/, docs/, governance/, hotfix/"
        echo "  Or branch name: develop"
        echo "  This is a warning - commit will proceed."
        echo ""
    else
        echo -e "${GREEN}  Branch naming OK${NC}"
    fi
fi

# ============================================
# 5. WARN: .gitignore modifications
# ============================================
echo "[3/5] Checking for .gitignore changes..."

if echo "$STAGED_FILES" | grep -q "\.gitignore"; then
    echo -e "${YELLOW}WARNING: .gitignore is being modified.${NC}"
    echo "  Changes to .gitignore can affect security boundaries."
    echo "  Ensure no security patterns are being removed."
    echo ""
fi

# ============================================
# 6. INFO: Category/branch alignment check
# ============================================
echo "[4/5] Checking category alignment..."

if echo "$BRANCH" | grep -q "^security/"; then
    echo "  Branch: security/* - expect sec: prefix in commit"
elif echo "$BRANCH" | grep -q "^feature/"; then
    echo "  Branch: feature/* - expect feat:/fix:/refactor: prefix in commit"
elif echo "$BRANCH" | grep -q "^docs/"; then
    echo "  Branch: docs/* - expect docs: prefix in commit"
elif echo "$BRANCH" | grep -q "^governance/"; then
    echo "  Branch: governance/* - expect const: prefix in commit"
fi

# ============================================
# 7. INFO: File count check
# ============================================
echo "[5/5] Reviewing staged changes..."

FILE_COUNT=$(echo "$STAGED_FILES" | wc -l)
echo "  $FILE_COUNT file(s) staged for commit"

if [ "$FILE_COUNT" -gt 20 ]; then
    echo -e "${YELLOW}  INFO: Large changeset (>20 files). Consider splitting.${NC}"
fi

echo ""
echo -e "${GREEN}=== Pre-Commit Validation PASSED ===${NC}"
exit 0
