/**
 * mail_integration.js
 * 
 * Comprehensive mail integration for email services
 * Handles authentication, mail synchronization, and message processing
 */

const fs = require('fs').promises;
const path = require('path');
const { simpleParser } = require('mailparser');

class MailIntegration {
  constructor(options = {}) {
    this.options = {
      mailboxFile: options.mailboxFile || './mailbox_data.json',
      syncInterval: options.syncInterval || 300000, // 5 minutes
      maxMessages: options.maxMessages || 100,
      retentionDays: options.retentionDays || 30,
      ...options
    };
    
    this.client = null;
    this.isInitialized = false;
    this.syncIntervalId = null;
    this.mailboxData = {
      messages: [],
      lastSync: null,
      unreadCount: 0,
      folders: {}
    };
  }

  /**
   * Initialize the mail integration
   */
  async initialize(credentials) {
    if (!credentials || !credentials.email || !credentials.password) {
      throw new Error('Mail credentials (email and password/app-specific password) are required for initialization');
    }

    // For now, we'll simulate the initialization
    // In a real implementation, this would connect to IMAP/POP3/Exchange
    console.log(`‚úÖ Mail integration initialized for ${credentials.email}`);
    
    // Initialize local mailbox data file
    await this.ensureLocalMailboxFile();
    
    this.isInitialized = true;
    return true;
  }

  /**
   * Ensure local mailbox data file exists
   */
  async ensureLocalMailboxFile() {
    try {
      await fs.access(this.options.mailboxFile);
    } catch (error) {
      // File doesn't exist, create with default structure
      const defaultData = {
        messages: [],
        lastSync: null,
        unreadCount: 0,
        folders: {
          inbox: [],
          sent: [],
          drafts: [],
          trash: []
        },
        settings: {
          maxMessages: this.options.maxMessages,
          retentionDays: this.options.retentionDays
        }
      };
      
      await fs.writeFile(this.options.mailboxFile, JSON.stringify(defaultData, null, 2));
      console.log(`üìß Created new mailbox data file: ${this.options.mailboxFile}`);
    }
  }

  /**
   * Fetch emails from the mail service (simulated)
   */
  async fetchEmails(folder = 'INBOX', limit = 10) {
    // In a real implementation, this would connect to IMAP/POP3
    // For now, we'll simulate by reading from a local file or returning mock data
    
    console.log(`üì• Fetching emails from ${folder}...`);
    
    // Simulate fetching emails
    const simulatedEmails = [
      {
        id: Date.now(),
        subject: "Test Email from Mail Integration",
        from: "system@openclaw.ai",
        to: "user@example.com",
        date: new Date().toISOString(),
        body: "This is a test email from the OpenClaw mail integration system.",
        folder: folder,
        flags: ['\\Seen'], // IMAP flags
        size: 1200
      }
    ];
    
    return simulatedEmails;
  }

  /**
   * Synchronize mailbox to local storage
   */
  async syncToLocalStorage() {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }

    try {
      console.log('üîÑ Syncing mailbox data...');
      
      // Fetch recent emails (simulated)
      const inboxEmails = await this.fetchEmails('INBOX', 10);
      const sentEmails = await this.fetchEmails('SENT', 5);
      
      // Read existing mailbox data
      let mailboxData = await this.readMailboxData();
      
      // Update messages
      const newMessages = [...inboxEmails, ...sentEmails];
      
      // Combine with existing messages, avoiding duplicates
      const existingIds = new Set(mailboxData.messages.map(msg => msg.id));
      const uniqueNewMessages = newMessages.filter(msg => !existingIds.has(msg.id));
      
      mailboxData.messages = [...uniqueNewMessages, ...mailboxData.messages].slice(0, this.options.maxMessages);
      
      // Update folders
      mailboxData.folders.inbox = [...uniqueNewMessages.filter(msg => msg.folder === 'INBOX'), ...mailboxData.folders.inbox].slice(0, this.options.maxMessages);
      mailboxData.folders.sent = [...uniqueNewMessages.filter(msg => msg.folder === 'SENT'), ...mailboxData.folders.sent].slice(0, this.options.maxMessages);
      
      // Update unread count
      mailboxData.unreadCount = mailboxData.messages.filter(msg => !msg.flags.includes('\\Seen')).length;
      mailboxData.lastSync = new Date().toISOString();

      // Write back to the file
      await fs.writeFile(this.options.mailboxFile, JSON.stringify(mailboxData, null, 2));

      console.log(`‚úÖ Synced ${uniqueNewMessages.length} new messages to local storage.`);
      
      return {
        messagesSynced: uniqueNewMessages.length,
        totalMessages: mailboxData.messages.length,
        unreadCount: mailboxData.unreadCount,
        lastSync: mailboxData.lastSync
      };
    } catch (error) {
      console.error('‚ùå Error syncing mailbox to local storage:', error);
      throw error;
    }
  }

  /**
   * Read mailbox data from local file
   */
  async readMailboxData() {
    try {
      const data = await fs.readFile(this.options.mailboxFile, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      throw new Error(`Error reading mailbox data: ${error.message}`);
    }
  }

  /**
   * Get mailbox summary
   */
  async getMailboxSummary() {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }

    try {
      // Ensure we have current data
      await this.syncToLocalStorage();
      
      const mailboxData = await this.readMailboxData();
      
      // Calculate summary statistics
      const totalMessages = mailboxData.messages.length;
      const unreadCount = mailboxData.unreadCount;
      const readCount = totalMessages - unreadCount;
      
      // Get recent messages
      const recentMessages = mailboxData.messages.slice(0, 5);
      
      // Calculate folder statistics
      const folderStats = {};
      for (const [folderName, messages] of Object.entries(mailboxData.folders)) {
        folderStats[folderName] = {
          count: messages.length,
          unread: messages.filter(msg => !msg.flags?.includes('\\Seen')).length
        };
      }
      
      return {
        summary: {
          totalMessages,
          unreadCount,
          readCount,
          folders: folderStats,
          lastSync: mailboxData.lastSync
        },
        recentMessages,
        dateRange: {
          start: mailboxData.messages.length > 0 ? 
            new Date(Math.min(...mailboxData.messages.map(m => new Date(m.date)))) : null,
          end: new Date()
        }
      };
    } catch (error) {
      console.error('‚ùå Error getting mailbox summary:', error);
      throw error;
    }
  }

  /**
   * Mark messages as read/unread
   */
  async markAsRead(messageIds, read = true) {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }

    try {
      const mailboxData = await this.readMailboxData();
      
      // Update message flags
      for (const message of mailboxData.messages) {
        if (messageIds.includes(message.id)) {
          if (read) {
            // Add seen flag if not already present
            if (!message.flags.includes('\\Seen')) {
              message.flags.push('\\Seen');
            }
          } else {
            // Remove seen flag if present
            message.flags = message.flags.filter(flag => flag !== '\\Seen');
          }
        }
      }
      
      // Update unread count
      mailboxData.unreadCount = mailboxData.messages.filter(msg => !msg.flags.includes('\\Seen')).length;
      
      // Write back to file
      await fs.writeFile(this.options.mailboxFile, JSON.stringify(mailboxData, null, 2));
      
      console.log(`‚úÖ Marked ${messageIds.length} messages as ${read ? 'read' : 'unread'}`);
      
      return {
        success: true,
        updatedCount: messageIds.length,
        newUnreadCount: mailboxData.unreadCount
      };
    } catch (error) {
      console.error('‚ùå Error marking messages:', error);
      throw error;
    }
  }

  /**
   * Send an email (simulated)
   */
  async sendEmail(to, subject, body, options = {}) {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }

    try {
      const newMessage = {
        id: `sent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        subject: subject,
        from: options.from || "user@example.com", // Would come from credentials in real implementation
        to: Array.isArray(to) ? to : [to],
        date: new Date().toISOString(),
        body: body,
        folder: 'sent',
        flags: ['\\Seen'],
        size: body.length
      };

      // Add to sent folder
      const mailboxData = await this.readMailboxData();
      mailboxData.folders.sent.unshift(newMessage);
      
      // Limit sent folder size
      mailboxData.folders.sent = mailboxData.folders.sent.slice(0, this.options.maxMessages);
      
      // Also add to general messages list
      mailboxData.messages.unshift(newMessage);
      mailboxData.messages = mailboxData.messages.slice(0, this.options.maxMessages);
      
      // Write back to file
      await fs.writeFile(this.options.mailboxFile, JSON.stringify(mailboxData, null, 2));
      
      console.log(`‚úÖ Sent email to ${Array.isArray(to) ? to.join(', ') : to}: ${subject}`);
      
      return {
        success: true,
        messageId: newMessage.id,
        recipients: newMessage.to,
        subject: newMessage.subject
      };
    } catch (error) {
      console.error('‚ùå Error sending email:', error);
      throw error;
    }
  }

  /**
   * Search messages
   */
  async searchMessages(query, options = {}) {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }

    try {
      const mailboxData = await this.readMailboxData();
      
      // Simple search implementation
      const searchTerm = query.toLowerCase();
      let results = mailboxData.messages;
      
      // Apply filters
      if (options.folder) {
        results = results.filter(msg => msg.folder === options.folder);
      }
      
      if (options.unreadOnly) {
        results = results.filter(msg => !msg.flags.includes('\\Seen'));
      }
      
      // Apply search term
      results = results.filter(msg => 
        msg.subject.toLowerCase().includes(searchTerm) ||
        msg.body.toLowerCase().includes(searchTerm) ||
        msg.from.toLowerCase().includes(searchTerm) ||
        (msg.to && msg.to.some(recipient => recipient.toLowerCase().includes(searchTerm)))
      );
      
      // Apply date range filter
      if (options.dateFrom) {
        const fromDate = new Date(options.dateFrom);
        results = results.filter(msg => new Date(msg.date) >= fromDate);
      }
      
      if (options.dateTo) {
        const toDate = new Date(options.dateTo);
        results = results.filter(msg => new Date(msg.date) <= toDate);
      }
      
      // Sort by date (newest first)
      results.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      // Apply limit
      if (options.limit) {
        results = results.slice(0, options.limit);
      }
      
      return {
        results,
        totalCount: results.length,
        query
      };
    } catch (error) {
      console.error('‚ùå Error searching messages:', error);
      throw error;
    }
  }

  /**
   * Start automatic synchronization
   */
  startAutoSync() {
    if (!this.isInitialized) {
      throw new Error('Mail integration not initialized. Call initialize() first.');
    }
    
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
    }

    this.syncIntervalId = setInterval(async () => {
      try {
        await this.syncToLocalStorage();
      } catch (error) {
        console.error('‚ùå Auto-sync failed:', error);
      }
    }, this.options.syncInterval);

    console.log(`üîÑ Mail auto-sync started. Interval: ${this.options.syncInterval / 60000} minutes.`);
  }

  /**
   * Stop automatic synchronization
   */
  stopAutoSync() {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
      console.log('‚èπÔ∏è  Mail auto-sync stopped.');
    }
  }

  /**
   * Test the mail connection
   */
  async testConnection() {
    try {
      // In a real implementation, this would test the actual mail server connection
      // For now, we'll just verify the local file structure is OK
      
      const mailboxData = await this.readMailboxData();
      
      return {
        connected: true,
        mailboxReady: true,
        totalMessages: mailboxData.messages.length,
        unreadCount: mailboxData.unreadCount,
        lastTest: new Date().toISOString()
      };
    } catch (error) {
      return {
        connected: false,
        error: error.message
      };
    }
  }

  /**
   * Get the current sync status
   */
  getSyncStatus() {
    return {
      initialized: this.isInitialized,
      lastSync: this.mailboxData.lastSync,
      autoSyncEnabled: !!this.syncIntervalId,
      syncInterval: this.options.syncInterval,
      totalMessages: this.mailboxData.messages.length,
      unreadCount: this.mailboxData.unreadCount
    };
  }

  /**
   * Close the mail integration and clean up
   */
  async close() {
    this.stopAutoSync();
    this.isInitialized = false;
    console.log('üîí Mail integration closed.');
  }
}

module.exports = MailIntegration;

// Example usage:
/*
const mailIntegration = new MailIntegration();

async function setupMail() {
  try {
    await mailIntegration.initialize({
      email: process.env.MAIL_USERNAME,
      password: process.env.MAIL_PASSWORD
    });
    
    mailIntegration.startAutoSync();
    
    const summary = await mailIntegration.getMailboxSummary();
    console.log('Mailbox summary:', summary.summary);
  } catch (error) {
    console.error('Setup failed:', error);
  }
}
*/
