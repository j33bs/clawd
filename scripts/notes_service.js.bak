// notes_service.js
// Append-only notes capture and retrieval service

const fs = require('fs');
const path = require('path');

class NotesService {
  constructor(config = {}) {
    this.config = {
      notesDirectory: config.notesDirectory || './notes',
      defaultCategory: config.defaultCategory || 'general',
      ...config
    };
    
    // Initialize notes directory
    this.initNotesStore();
  }

  // Initialize notes store
  initNotesStore() {
    if (!fs.existsSync(this.config.notesDirectory)) {
      fs.mkdirSync(this.config.notesDirectory, { recursive: true });
    }
  }

  // Append a new note (append-only operation)
  async appendNote(content, category = null, tags = []) {
    try {
      const note = {
        id: this.generateId(),
        content: content,
        category: category || this.config.defaultCategory,
        tags: tags,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // Create category directory if it doesn't exist
      const categoryDir = path.join(this.config.notesDirectory, note.category);
      if (!fs.existsSync(categoryDir)) {
        fs.mkdirSync(categoryDir, { recursive: true });
      }
      
      // Write note to file
      const notePath = path.join(categoryDir, `${note.id}.json`);
      fs.writeFileSync(notePath, JSON.stringify(note, null, 2));
      
      return note;
    } catch (error) {
      throw new Error(`Failed to append note: ${error.message}`);
    }
  }

  // Retrieve notes by category
  async retrieveByCategory(category) {
    try {
      const categoryDir = path.join(this.config.notesDirectory, category);
      if (!fs.existsSync(categoryDir)) {
        return [];
      }
      
      const files = fs.readdirSync(categoryDir);
      const notes = [];
      
      for (const file of files) {
        if (file.endsWith('.json')) {
          const notePath = path.join(categoryDir, file);
          const noteData = JSON.parse(fs.readFileSync(notePath, 'utf8'));
          notes.push(noteData);
        }
      }
      
      // Sort by creation date (newest first)
      return notes.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    } catch (error) {
      throw new Error(`Failed to retrieve notes by category: ${error.message}`);
    }
  }

  // Search notes by content or tags
  async search(query, category = null) {
    try {
      let allNotes = [];
      
      if (category) {
        // Search within specific category
        allNotes = await this.retrieveByCategory(category);
      } else {
        // Search across all categories
        const categories = fs.readdirSync(this.config.notesDirectory).filter(item => 
          fs.statSync(path.join(this.config.notesDirectory, item)).isDirectory()
        );
        
        for (const cat of categories) {
          const categoryNotes = await this.retrieveByCategory(cat);
          allNotes = allNotes.concat(categoryNotes);
        }
      }
      
      // Filter notes based on query
      const normalizedQuery = query.toLowerCase();
      const matchingNotes = allNotes.filter(note => {
        // Check content, tags, and category
        return (
          note.content.toLowerCase().includes(normalizedQuery) ||
          note.tags.some(tag => tag.toLowerCase().includes(normalizedQuery)) ||
          note.category.toLowerCase().includes(normalizedQuery)
        );
      });
      
      // Sort by relevance (notes with query in content rank higher)
      return matchingNotes.sort((a, b) => {
        const aContentMatch = a.content.toLowerCase().includes(normalizedQuery) ? 2 : 0;
        const bContentMatch = b.content.toLowerCase().includes(normalizedQuery) ? 2 : 0;
        const aTagMatch = a.tags.some(tag => tag.toLowerCase().includes(normalizedQuery)) ? 1 : 0;
        const bTagMatch = b.tags.some(tag => tag.toLowerCase().includes(normalizedQuery)) ? 1 : 0;
        
        return (bContentMatch + bTagMatch) - (aContentMatch + aTagMatch);
      });
    } catch (error) {
      throw new Error(`Failed to search notes: ${error.message}`);
    }
  }

  // Get all available categories
  async getCategories() {
    try {
      return fs.readdirSync(this.config.notesDirectory).filter(item => 
        fs.statSync(path.join(this.config.notesDirectory, item)).isDirectory()
      );
    } catch (error) {
      throw new Error(`Failed to get categories: ${error.message}`);
    }
  }

  // Get note statistics
  async getStats() {
    try {
      const categories = await this.getCategories();
      const stats = {
        totalNotes: 0,
        categories: {},
        tags: {}
      };
      
      for (const category of categories) {
        const notes = await this.retrieveByCategory(category);
        stats.categories[category] = notes.length;
        stats.totalNotes += notes.length;
        
        // Collect tag frequencies
        notes.forEach(note => {
          note.tags.forEach(tag => {
            stats.tags[tag] = (stats.tags[tag] || 0) + 1;
          });
        });
      }
      
      return stats;
    } catch (error) {
      throw new Error(`Failed to get stats: ${error.message}`);
    }
  }

  // Get a specific note by ID and category
  async getNoteById(id, category) {
    try {
      const notePath = path.join(this.config.notesDirectory, category, `${id}.json`);
      if (!fs.existsSync(notePath)) {
        return null;
      }
      
      return JSON.parse(fs.readFileSync(notePath, 'utf8'));
    } catch (error) {
      throw new Error(`Failed to get note by ID: ${error.message}`);
    }
  }

  // Generate unique ID for notes
  generateId() {
    return `note_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Get recent notes
  async getRecent(count = 10) {
    try {
      const allNotes = [];
      const categories = await this.getCategories();
      
      for (const cat of categories) {
        const categoryNotes = await this.retrieveByCategory(cat);
        allNotes.push(...categoryNotes);
      }
      
      // Sort by creation date (newest first) and return requested count
      return allNotes
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
        .slice(0, count);
    } catch (error) {
      throw new Error(`Failed to get recent notes: ${error.message}`);
    }
  }

  // Validate note content
  validateNote(content, category, tags) {
    if (!content || typeof content !== 'string' || content.trim().length === 0) {
      return { valid: false, error: 'Content is required and must be a non-empty string' };
    }
    
    if (category && typeof category !== 'string') {
      return { valid: false, error: 'Category must be a string if provided' };
    }
    
    if (tags && !Array.isArray(tags)) {
      return { valid: false, error: 'Tags must be an array if provided' };
    }
    
    return { valid: true };
  }
}

module.exports = NotesService;
